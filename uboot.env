# Custom U-Boot base environment for Nerves

# This environment contains the default firmware variables for the NanoPi Neo2
# with slight additions and modifications for Nerves.
#
# Why?
#   1. We want to store settings in the U-boot environment so that they're
#      accessible both to Elixir and U-boot.
#   2. This makes us add an environment block.
#   3. Unfortunately, if we point U-Boot to this block, it replaces its
#      default environment settings which contain all of the logic to
#      boot the boards. Therefore we have to copy/paste the relevant
#      parts here.
#   4. The Nerves variables allow us to support firmware validation methods that
#      defer validation of new software to the application. The default below is
#      to automatically validate new software.

#
# Nerves variables for validation
#

# nerves_fw_autovalidate controls whether updates are considered valid once
# applied. If set to 0, the user needs to set nerves_fw_validated to 1 in their
# application. If they don't set it before a reboot, then the previous software
# is run. If 1, then no further action needs to be taken.
nerves_fw_autovalidate=1

# nerves_fw_validated is 1 if the current boot selection is accepted. It is set
# to 1 here, since this environment is written in the factory, so it is
# implicitly valid.
nerves_fw_validated=1

# nerves_fw_booted is 0 for the first boot and 1 for all reboots after that.
# NOTE: Keep this '0' so that all new boards run a 'saveenv' to exercise the
#       code that writes back to the eMMC early on.
nerves_fw_booted=0

#
# Nerves initialization logic
#

# The nerves_init code is run at boot (see the last line of the file). It
# checks whether this is a first boot or not. If it's not the first boot, then
# the firmware better be validated or it reverts to running the firmware on the
# opposite partition.
nerves_revert=\
    if test ${nerves_fw_active} = "a"; then\
        echo "Reverting to partition B";\
        setenv nerves_fw_active "b";\
    else\
        echo "Reverting to partition A";\
        setenv nerves_fw_active "a";\
    fi

nerves_init=\
    if test ${nerves_fw_booted} = 1; then\
        if test ${nerves_fw_validated} = 0; then\
            run nerves_revert;\
            setenv nerves_fw_validated 1;\
            saveenv;\
        fi;\
    else\
        setenv nerves_fw_booted 1;\
        if test ${nerves_fw_autovalidate} = 1; then\
            setenv nerves_fw_validated 1;\
        fi;\
        saveenv;\
    fi;\
    setenv bootfile Image.${nerves_fw_active};\
    if test ${nerves_fw_active} = "a"; then\
        setenv uenv_root /dev/mmcblk0p2;\
    else\
        setenv uenv_root /dev/mmcblk0p3;\
    fi

#
# Default firmware variables for the NanoPi Neo2. The only exceptions are the
# last two lines, which has been modified to skip the boot delay and run the
# nerves_init script.
#

arch=arm
baudrate=115200
board=sunxi
board_name=sunxi
boot_a_script=load ${devtype} ${devnum}:${distro_bootpart} ${scriptaddr} ${prefix}${script}; source ${scriptaddr}
boot_efi_binary=if fdt addr ${fdt_addr_r}; then bootefi bootmgr ${fdt_addr_r};else bootefi bootmgr ${fdtcontroladdr};fi;load ${devtype} ${devnum}:${distro_bootpart} ${kernel_addr_r} efi/boot/bootaa64.efi; if fdt addr ${fdt_addr_r}; then bootefi ${kernel_addr_r} ${fdt_addr_r};else bootefi ${kernel_addr_r} ${fdtcontroladdr};fi
boot_extlinux=sysboot ${devtype} ${devnum}:${distro_bootpart} any ${scriptaddr} ${prefix}extlinux/extlinux.conf
boot_net_usb_start=usb start
boot_prefixes=/ /boot/
boot_script_dhcp=boot.scr.uimg
boot_scripts=boot.scr.uimg boot.scr
boot_targets=fel mmc0 usb0 pxe dhcp
bootcmd_dhcp=run boot_net_usb_start; if dhcp ${scriptaddr} ${boot_script_dhcp}; then source ${scriptaddr}; fi;setenv efi_fdtfile ${fdtfile}; setenv efi_old_vci ${bootp_vci};setenv efi_old_arch ${bootp_arch};setenv bootp_vci PXEClient:Arch:00011:UNDI:003000;setenv bootp_arch 0xb;if dhcp ${kernel_addr_r}; then tftpboot ${fdt_addr_r} dtb/${efi_fdtfile};if fdt addr ${fdt_addr_r}; then bootefi ${kernel_addr_r} ${fdt_addr_r}; else bootefi ${kernel_addr_r} ${fdtcontroladdr};fi;fi;setenv bootp_vci ${efi_old_vci};setenv bootp_arch ${efi_old_arch};setenv efi_fdtfile;setenv efi_old_arch;setenv efi_old_vci;
bootcmd_fel=if test -n ${fel_booted} && test -n ${fel_scriptaddr}; then echo '(FEL boot)'; source ${fel_scriptaddr}; fi
bootcmd_mmc0=setenv devnum 0; run mmc_boot
bootcmd_pxe=run boot_net_usb_start; dhcp; if pxe get; then pxe boot; fi
bootcmd_usb0=setenv devnum 0; run usb_boot
bootm_size=0xa000000
console=ttyS0,115200
cpu=armv8
dfu_alt_info_ram=kernel ram 0x40080000 0x1000000;fdt ram 0x4FA00000 0x100000;ramdisk ram 0x4FE00000 0x4000000
distro_bootcmd=for target in ${boot_targets}; do run bootcmd_${target}; done
efi_dtb_prefixes=/ /dtb/ /dtb/current/
fdt_addr_r=0x4FA00000
fdtfile=allwinner/sun50i-h5-nanopi-neo2.dtb
kernel_addr_r=0x40080000
load_efi_dtb=load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix}${efi_fdtfile}
mmc_boot=if mmc dev ${devnum}; then setenv devtype mmc; run scan_dev_for_boot_part; fi
preboot=usb start
pxefile_addr_r=0x4FD00000
ramdisk_addr_r=0x4FE00000
scan_dev_for_boot=echo Scanning ${devtype} ${devnum}:${distro_bootpart}...; for prefix in ${boot_prefixes}; do run scan_dev_for_extlinux; run scan_dev_for_scripts; done;run scan_dev_for_efi;
scan_dev_for_boot_part=part list ${devtype} ${devnum} -bootable devplist; env exists devplist || setenv devplist 1; for distro_bootpart in ${devplist}; do if fstype ${devtype} ${devnum}:${distro_bootpart} bootfstype; then run scan_dev_for_boot; fi; done
scan_dev_for_efi=setenv efi_fdtfile ${fdtfile}; for prefix in ${efi_dtb_prefixes}; do if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${efi_fdtfile}; then run load_efi_dtb; fi;done;if test -e ${devtype} ${devnum}:${distro_bootpart} efi/boot/bootaa64.efi; then echo Found EFI removable media binary efi/boot/bootaa64.efi; run boot_efi_binary; echo EFI LOAD FAILED: continuing...; fi; setenv efi_fdtfile
scan_dev_for_extlinux=if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}extlinux/extlinux.conf; then echo Found ${prefix}extlinux/extlinux.conf; run boot_extlinux; echo SCRIPT FAILED: continuing...; fi
scan_dev_for_scripts=for script in ${boot_scripts}; do if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${script}; then echo Found U-Boot script ${prefix}${script}; run boot_a_script; echo SCRIPT FAILED: continuing...; fi; done
scriptaddr=0x4FC00000
soc=sunxi
stderr=serial,vidconsole
stdin=serial,usbkbd
stdout=serial,vidconsole
usb_boot=usb start; if usb dev ${devnum}; then setenv devtype usb; run scan_dev_for_boot_part; fi

bootdelay=-2
bootcmd=run nerves_init; run distro_bootcmd
